#!/usr/bin/perl -w
#get_radio V0.4
#works in all meaningful ways
#Allows multiple searches and channels for program downloading
#Caches the XML for the AOD pages so that the file is only pulled once
#Has a crude mechanism for identifying pids UNUSED
#Matches a program based on a regex of the title or the PID
#TODO:
#Error trapping:
#Spot when a media selector URL doesn't return data
#Make sure the stream selection works
#Resuming live recordings external loop or flvstreamer resume?
#Get cleverer about matching the live stream currently --live will turn off other methods
#fix playing live of AoD


# use module
use strict;
use Getopt::Long;
use Date::Format;
use Date::Parse;
#use XML::Simple qw(:strict);
use XML::Simple;
use Data::Dumper;
use Switch;
use HTTP::Request;
use LWP::UserAgent;
use IPC::Run qw( run start );
use File::Copy;
use if defined $ENV{DISPLAY} , "Gtk2";
#use Gtk2::Ex::Simple::List;
use if defined $ENV{DISPLAY} ,  "Gtk2::SimpleList";

# create object
my $xml = new XML::Simple;

#Some Vars
#inoticoming doesn't work with a station name that starts with a number
my %Channel = (
		1  => [ "bbc_radio_one"       , "radio1"     , "Radio1" ],
		2  => [ "bbc_radio_two"       , "radio2"     , "Radio2" ],
		3  => [ "bbc_radio_three"     , "radio3"     , "Radio3" ],
		4  => [ "bbc_radio_four"      , "radio4"     , "Radio4" ],
		5  => [ "bbc_radio_five_live" , "fivelive"   , "R5live"  ],
		6  => [ "bbc_6music"          , "6music"     , "R6music" ],
		7  => [ "bbc_7"               , "bbc7"       , "BBC7" ],
		10 => [ "bbc_radio_wales"     , "radiowales" , "RadioWales" ],
		11 => [ "bbc_wm"              , "bbcwm"      , "RadioWM" ],
);

my @SelChn   = ();
my @SelSer   = ();
my $SelSin   = 350;
my $DmpChn   = 0;
my $OutDir   = $ENV{HOME} || (getpwuid($<))[7] || '/tmp' ;
my $tmpdir   = '/tmp';
my $live     = 0;
my $chunk    = 30;
my $stop     = 180;
my $play     = 0;
my $get	     = 0;
my $MaxPids  = 5;
my $FlvPrt   = 1935;
my $Gui      = 0;

my $true     = 1;
my $false    = 0;
my $vol_label;
my $mute_label;
my $stn_play = "fivelive";
my $process  = 0;

#These variables are pretty global??
my (@flvcmd , @lamecmd ,@ffmpegcmd , @mp3spltcmd , @mplayercmd , @inoticmd , $PlayPath );
#Set Common Params
push ( @flvcmd     , ( '/usr/bin/flvstreamer' , '-q' ));
push ( @ffmpegcmd  , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' ));
push ( @mplayercmd , ( '/usr/bin/mplayer' , '-cache' , '8192' , '-' ));

GetOptions (
	'channel=s'	=> \@SelChn,
	'find=s'	=> \@SelSer,
	'since=i'	=> \$SelSin,
	'outdir=s'	=> \$OutDir,
	'get'		=> \$get,
	'live'		=> \$live,
	'chunk=i'	=> \$chunk,
	'end=i'		=> \$stop,
	'play'		=> \$play,
	'gui'		=> \$Gui,
	'help|dump'	=> \$DmpChn,
) or die "Incorrect usage use --help for assistance.\n";

#print "DEBUG:: $OutDir\n";

if ( $DmpChn == 1 ) {
	print "List of channels: \n";
	foreach my $stn ( sort {$a <=> $b} ( keys %Channel )) {
		print "$stn live pid: $Channel{$stn}[0], AOD XML: $Channel{$stn}[1], Pretty Output: $Channel{$stn}[2]\n";
	}

print "\nUsage: ARGV[0] --live --channel x --chunk y --end z --outdir <dir> [--play]\n";
print "--live:    download the specified channel, chunk will
           split the file every y mins, end, stop after z mins
           (Requires flvstreamer, ffmpeg, lame and mp3splt)
--play:    will play it (requires mplayer), chunk is ignored
--channel: a single integer refers to bb channels. see --help for a list.\n";

print "\nUsage: ARGV[0] [--get] --channel x[,y,z] --since n --outdir <dir> --find <string> [--find <string> --find <string>]\n";
print "default:   search in specified channels for search string(s)
--since:   will result in only searching for files available in the last n hours
--get:     fetch the files (needs flvstreamer and ffmpeg)
--channel: comma seperated list of channels to search (--help for list)
--play:    attempt to play, does not seem to work (needs mplayer to not work)\n";
exit;
}
sub isitaPID {
	my $testpid = shift;
	my $pidlth  = 8;
	my $pidsrt  = 'b00';
	if ( length($testpid) == $pidlth ) {
		#print "DEBUG:: It might be a pid it's 8 characters\n";
		if ( $testpid =~ m/^$pidsrt/ ) {
			#print "DEBUG:: It might be a pid it starts with $pidsrt\n";
			return 1;
		} else {
			#print "DEBUG:: It not a PID";
			return 0;
		}
	} else {
		#print "DEBUG:: It not a PID\n";
		return 0;
	}
}

sub processMediaSelector {
	my $SelBase = "http://www.bbc.co.uk/mediaselector/4/mtis/stream/";
	my $MedPid = shift;
	my @StrTyp = @_;
	# read XML file
	my $ua = LWP::UserAgent->new;
	my $raw = $ua->request(HTTP::Request->new( GET => $SelBase . $MedPid ) );
	my $data = $xml->XMLin($raw->content);
	my $media_index = 0;
	my $serv_index = 0;
	until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( defined($data->{media}[$media_index]->{service}) == 0 ) ) {
		$serv_index = 0;
		until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( $serv_index >= $#StrTyp ) ) {
               	++$serv_index;
		}
		if ( $data->{media}[$media_index]->{service} ne $StrTyp[$serv_index] ) {
                	++$media_index;
        	}
	}
	#print "DEBUG:: server should be $data->{media}[$media_index]->{connection}->{server}\n";
	#Initialise hash ....
	my %mattribs;
	my $fcsraw  = $ua->request(HTTP::Request->new( GET => "http://" . $data->{media}[$media_index]->{connection}->{server} . "/fcs/ident" ) );
	my $fcsdata = $xml->XMLin($fcsraw->content);
	%mattribs = (
		success    => 1,
		authString => $data->{media}[$media_index]->{connection}->{authString},
		identifier => $data->{media}[$media_index]->{connection}->{identifier},
		encoding   => $data->{media}[$media_index]->{encoding},
		server     => $data->{media}[$media_index]->{connection}->{server},
		ip	   => $fcsdata->{ip},
	);
	return %mattribs;
}
	
sub streamStation {
	my $chan  = shift;
	#print "DEBUG::channel $chan\n";
	my $show  = $Channel{$chan}[0];
	#print "DEBUG::show $show\n``";
	my $title = $Channel{$chan}[2];
	my @localtime = localtime(time);
	my $filetime = strftime("%Y%m%d_%H%M", @localtime);
	
	#This locks it to the low bandwidth iplayer flash stream
	my $stream = "iplayer_uk_stream_aac_rtmp_lo_live";
	my %attribs = processMediaSelector ( $show , $stream );
	#this command may need to be in the loop, I think the auth will fail after a period.....
	push ( @flvcmd , ( '-r' , "rtmp://$attribs{ip}:$FlvPrt/live" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/live?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}?$attribs{authString}&aifp=v001" , '--live' , '--flv' , '-' ));
	if ( $play == 1 ) {
		if ( $stop != 0 ) {
				$stop = ($stop * 60);
        			push ( @flvcmd , ( '--stop' , "$stop" ) );
		}
                run \@flvcmd , '|' , \@mplayercmd;
        } else {
                push ( @ffmpegcmd , ( '-i' , '-' , '-v' , '0' , '-vn' , '-f' , 'wav' , '-' ));
		my $counter = 1;
		my $runtot = 0;
                push ( @lamecmd , ( '/usr/bin/lame' , '--quiet' , '-a' , '-q', '7' , '--resample' , '44.1' , '-b' , '32' , '-' , "dummyname" ));
		if ( $stop != 0 ) {
			$stop = $stop * 60;
			$chunk = $chunk * 60;
			#push the default chunk length onto the end
        		push ( @flvcmd , ( '--stop' , "$chunk"  ) );
		} else {
			#If they haven't specified a stop stop after 4hrs with no chunks
			$stop = 14400;
			$chunk = 14400;
		}
		while ( $runtot < $stop ) {
			my $filename = "$filetime\_$counter\_$title.mp3";
			if ( ($stop - $runtot) < $chunk ) {
				$chunk = $stop - $runtot;
				pop ( @flvcmd );
        			push ( @flvcmd , "$chunk"  );
			}
			pop ( @lamecmd );
			push ( @lamecmd , ( "$tmpdir/$filename" ));
        	        run \@flvcmd , '|' , \@ffmpegcmd , '|' , \@lamecmd;
			my @mvcmd = ( '/bin/mv' , "$tmpdir/$filename" , "$OutDir/$filename" );
                        if ( $process != 0 ) {
                                finish $process;
                        }
                        $process = start \@mvcmd;
			$runtot = $runtot + $chunk;
				
			$counter = ++$counter;
		}
	}
}

sub downloadPID {
	my @shows  = @_;
	my @stream = ( "iplayer_uk_stream_mp3" , "iplayer_intl_stream_mp3");
	#my @stream = ( "iplayer_uk_stream_mp3" );
	#print Dumper (@shows);
	my $show_index = 0;
	my %attribs;
	until ( $show_index == ($#shows+1) ) {
		#make the title safe
		my $title = $shows[$show_index][1];
		$title =~ tr/a-zA-Z0-9/_/c;
		$title = $title . '_' . $shows[$show_index][0];
		my $stream_index = 0;
		#print "DEBUG:: show pid $shows[$show_index][0] , stream id $stream[$stream_index]\n";
		my %attribs = processMediaSelector ( $shows[$show_index][0] , @stream );
		#Check if file exists and don't download if it does
		if ( -e "$OutDir/$title.$attribs{encoding}" ) {
			print "File $OutDir/$title.$attribs{encoding} Exists Do Not Download!!\n";
		} else {
			#print "will now download \n";
        		push ( @flvcmd , ( '--resume' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/ondemand" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/ondemand?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}" ));
			if ( $play == 1 ) {
				push ( @flvcmd, '--flv' , '-' );
                		run \@flvcmd , '|' , \@mplayercmd;
			} else {
				push ( @flvcmd, '--flv' , "$tmpdir/$title.$attribs{encoding}" );
				run \@flvcmd;
				#print Dumper(@flvcmd);
				push ( @ffmpegcmd , ( '-i' , "$tmpdir/$title.$attribs{encoding}" , '-acodec' , 'copy' , "$OutDir/$title.$attribs{encoding}"  ));
				#print Dumper(@ffmpegcmd);
				run \@ffmpegcmd;
                		unlink "$tmpdir/$title.$attribs{encoding}";
			}
		}
		++$show_index;
	}
		
}

sub searchShow {
	my @SelPid   = ();
	my $AodBase  = "http://www.bbc.co.uk/radio/aod/availability/";
	my $SelSuff  = ".xml";
	my $search   = shift;
	my $since    = shift;
	my @channels = @_;
	my $now      = time();
	#isitaPID ($search);
	foreach my $station ( @channels ) {
		if (!defined($Channel{$station}[3])) {
			# read XML file
			my $ua = LWP::UserAgent->new;
			my $raw = $ua->request(HTTP::Request->new( GET => $AodBase . $Channel{$station}[1] . $SelSuff ) );
			#Push the XML out into the Channel hash, this saves exessive calls to the BBC website
			$Channel{$station}[3] = $xml->XMLin($raw->content, ForceArray => 'entry' );
		}
		my $entry_index = 0;
		my $data = \$Channel{$station}[3];
		#print "DEBUG:: $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}\n";
		until ( defined($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}) == 0 ) {
			if (( $$data->{entry}[$entry_index]->{title}[0] =~ /$search/i ) || ( $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid} eq $search )) {
				my $added = str2time($$data->{entry}[$entry_index]->{availability}[0]->{start});
				if ( ( $added >= $now - ( $since * 3600 )) && ( $added <= $now )) {
					my @TmpArray = ();
					#print "DEBUG:: ( $$data->{entry}[$entry_index]->{title}[0] $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}  $search \n";
					@TmpArray = ($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid},$$data->{entry}[$entry_index]->{title}[0],$$data->{entry}[$entry_index]->{availability}[0]->{start},$Channel{$station}[2]);
					push ( @SelPid, ( [@TmpArray] ) );
				}
			}
			++$entry_index;
		}
	}
	return @SelPid;
}

sub getvol {
	my $out;
	my @amcmd = ('/usr/bin/amixer' , 'get' , 'Master' );
	my @grcmd = ( '/bin/grep' , 'Front Left:' );
	run ( \@amcmd , '|' , \@grcmd , '>' , \$out ); 
	my @vol_array = split ( / +/ , $out );
	#print Dumper ( @vol_array );
	$vol_label->set_label("Current Volume: ". $vol_array[4]);
	if ( $vol_array[7]  =~ m/on/ ) {
		$mute_label->set_label("Mute Off");
		return ($vol_array[4] , $true);
	} else {
		$mute_label->set_label("Mute On");
		return ($vol_array[4] , $false);
	}
}


sub volume {
	shift;
	print Dumper ( @_ );
	my $action = shift;
	my @vol_state = getvol;

	print "DEBUG:: action $action";
	my @amcmd = ('/usr/bin/amixer' , '-q' , 'cset' );

	switch ($action) {

		case "mute" {
			 if ($vol_state[1] == $true) {
                                #print "unmute";
                                system ('/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Switch" off');
                        } else {
                                #print "mute";
                                system ('/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Switch" on');
                        }
		}
	
		case "up" {
			#print "vol up $vol_state[0]\n";
			system ( '/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Volume" '.++$vol_state[0] );
		}
		case "down" {
			#print "vol down $vol_state[0]\n";
			system ( '/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Volume" '.--$vol_state[0] );
		}
	}	
	getvol;
}

sub  ip_addr {
	my $interface;
	my %IPs;

	foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        	$interface = $1 if /^(\S+?):?\s/;
        	next unless defined $interface;
        	$IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        	$IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
	}

	print Dumper(\%IPs);
}

sub refresh_status {

getvol;

}
sub startGui {

Gtk2->init;

# Create the window
my $base_win = new Gtk2::Window( "toplevel" );
$base_win->set_title( "RadioControl" );
$base_win->signal_connect( "destroy", sub { Gtk2->main_quit; });
$base_win->set_border_width( 10 );

# Create the main vertical box.
my $base_vbox = new Gtk2::VBox( $false, $false );
$base_win->add( $base_vbox );

# Create a horizontal frame
my $base_frame = new Gtk2::Frame( "JoggControl" );
$base_vbox->pack_start( $base_frame, $true, $true, 10 );

my $sub_hbox = new Gtk2::HBox( $false, $false );
$base_vbox->pack_start( $sub_hbox, $true, $true, 10 );

	my $hbbox = new Gtk2::HButtonBox();
	$hbbox->set_border_width( 5 );
	$hbbox->set_layout( "spread" );
	$hbbox->set_spacing( 30 );

	my $ss_button = new Gtk2::Button( "Start SlideShow" );
	$ss_button->signal_connect('clicked' => \&start_slideshow );
	$hbbox->add( $ss_button );

	my $volup_button = new Gtk2::Button( "Vol Up" );
	$volup_button->signal_connect('clicked' => \&volume , "up" );
	$hbbox->add( $volup_button );

	my $voldn_button = new Gtk2::Button( "Vol Dn" );
	$voldn_button->signal_connect('clicked' => \&volume , "down" );
	$hbbox->add( $voldn_button );

	my $mute_button = new Gtk2::Button( "Mute" );
	$mute_button->signal_connect('clicked' => \&volume , "mute" );
	$hbbox->add( $mute_button );

	my $exit_button = new Gtk2::Button( "Exit" );
	$exit_button->signal_connect('clicked' => sub { $base_win->destroy });
	$hbbox->add( $exit_button );

	$base_frame->add( $hbbox );



	my $left_vframe = new Gtk2::Frame( "Radio Select" );
	my $mid_vframe = new Gtk2::Frame( "Radio Control" );
	my $right_vframe = new Gtk2::Frame( "Status and Info" );

	$sub_hbox->pack_start($left_vframe, $true, $true, 10);
	$sub_hbox->pack_start($mid_vframe, $true, $true, 10);
	$sub_hbox->pack_start($right_vframe, $true, $true, 10);

	my $mid_vbbox = new Gtk2::VButtonBox();
	$mid_vbbox->set_border_width( 5 );
	$mid_vframe->add( $mid_vbbox );
	#$mid_vbbox->set_layout( "spread" );
	$mid_vbbox->set_spacing( 30 );

	my $radio_button = new Gtk2::Button( "Start Radio" );
	$radio_button->signal_connect('clicked' => \&streamStation , $stn_play );
	$mid_vbbox->add( $radio_button );

	my $stn_label = new Gtk2::Label ( "Station to Play:" );
	$mid_vbbox->add( $stn_label );
	my $stn_seltd = new Gtk2::Label ( "Please Select a Station" );
	$mid_vbbox->add( $stn_seltd );

	my $selstn_button = new Gtk2::Button( "Select File" );
	$selstn_button->signal_connect('clicked' => \&select_station );
	$mid_vbbox->add( $selstn_button );

	my $left_vbox = new Gtk2::VBox( $false, $false );
	$left_vframe->add ($left_vbox);
	my $stn_slist = Gtk2::SimpleList->new  (
		'Station' => 'text',
		'XML'	  => 'text',
		'Name'	  => 'text',
        );
        #@{$stn_slist->{data}} = %Channel;
	foreach my $stn ( sort {$a <=> $b} ( keys %Channel )) {
		push  (@{$stn_slist->{data}} , ( [$Channel{$stn}[0], $Channel{$stn}[1], $Channel{$stn}[2]] ));
	}
	#$stn_slist->remove_column ($stn_slist->get_column (0));
	#$stn_slist->remove_column ($stn_slist->get_column (0));
        $left_vbox->pack_start($stn_slist, $true, $true, 10 );

        $stn_slist->get_selection->signal_connect ( changed => sub {
                my ($selection) = @_;
                my $stn_slist = $selection->get_tree_view;
                my ($sel) = $stn_slist->get_selected_indices;
                $stn_play = $stn_slist->{data}[$sel][1];

                #print Dumper $tiedlist;
		$stn_seltd->set_label($stn_play);

        });

	my $choose_button = Gtk2::FileChooserButton->new('Select Mp3' , 'open' );
        $left_vbox->pack_start($choose_button, $true, $true, 10 );

	my $right_vbbox = new Gtk2::VButtonBox();
	$right_vbbox->set_border_width( 5 );
	$right_vframe->add( $right_vbbox );
	#$right_vbbox->set_layout( "spread" );
	$right_vbbox->set_spacing( 30 );
	$vol_label = new Gtk2::Label ( "Current Volume: ??" );
	$right_vbbox->add( $vol_label );
	$mute_label = new Gtk2::Label ( "mute?" );
	$right_vbbox->add( $mute_label );
	my $ip_label = new Gtk2::Label ( "IP Address:" );
	$right_vbbox->add( $ip_label );
	my $ip_addr = new Gtk2::Label ( "IP Address" );
	$right_vbbox->add( $ip_addr );

	my $refresh_button = new Gtk2::Button( "_Refresh" );
	$refresh_button->signal_connect('clicked' => \&refresh_status );
	$right_vbbox->add( $refresh_button );

	$base_win->show_all;
	Gtk2->main;

}


#Main Code starts here
#Always convert the channel to an array (needs error checking)#
#For a live stream only use the first one
@SelChn = split(/,/,join(',',@SelChn));
#If its live we can bypass the search part and jump straight to the streaming

if ( $Gui  == 1 ) {
	print ("load gui");

    startGui

} elsif ( $live == 1 ) {
	streamStation ( $SelChn[0] );
} else {
	my @Results = ();
	foreach my $look (@SelSer) {
		push ( @Results  , (searchShow ( $look , $SelSin , @SelChn )));
	}
		if ( $get == 1 ) {
			#print "calling downloadPID \n";
			downloadPID (@Results);
		} else {
			print Dumper (@Results);
		}
}
