#!/usr/bin/perl -w
#get_radio V0.4
#works in all meaningful ways
#Allows multiple searches and channels for program downloading
#Caches the XML for the AOD pages so that the file is only pulled once
#Has a crude mechanism for identifying pids UNUSED
#Matches a program based on a regex of the title or the PID
#TODO:
#Error trapping:
#Spot when a media selector URL doesn't return data
#Make sure the stream selection works
#Resuming live recordings external loop or flvstreamer resume?
#Get cleverer about matching the live stream currently --live will turn off other methods
#fix playing live of AoD


# use module
use strict;
use Getopt::Long;
use Date::Format;
use Date::Parse;
#use XML::Simple qw(:strict);
use XML::Simple;
use Data::Dumper;
use Switch;
use HTTP::Request;
use LWP::UserAgent;
use IPC::Run qw( run start );
use File::Copy;
use if defined $ENV{DISPLAY} , "Gtk2";
#use Gtk2::Ex::Simple::List;
use if defined $ENV{DISPLAY} , "Gtk2::SimpleList";

# create object
my $xml = new XML::Simple;

#Some Vars
#inoticoming doesn't work with a station name that starts with a number
my %Channel = (
		1  => [ "bbc_radio_one"       , "radio1"     , "Radio 1" ],
		2  => [ "bbc_radio_two"       , "radio2"     , "Radio 2" ],
		3  => [ "bbc_radio_three"     , "radio3"     , "Radio 3" ],
		4  => [ "bbc_radio_fourfm"    , "radio4"     , "Radio 4" ],
		5  => [ "bbc_radio_five_live" , "fivelive"   , "R5 live"  ],
		6  => [ "bbc_6music"          , "6music"     , "R6music" ],
		7  => [ "bbc_7"               , "bbc7"       , "BBC 7  " ],
		10 => [ "bbc_radio_wales_fm"  , "radiowales" , "R.Wales" ],
		11 => [ "bbc_wm"              , "bbc_wm"     , "RadioWM" ],
);

my @SelChn     = ();
my @SelSer     = ();
my $SelSin     = 350;
my $DmpChn     = 0;
my $OutDir     = $ENV{HOME} || (getpwuid($<))[7] || '/tmp' ;
my $tmpdir     = '/tmp';
my $live       = 0;
my $chunk      = 30;
my $stop       = 180;
my $play       = 0;
my $get	       = 0;
my $MaxPids    = 5;
my $FlvPrt     = 1935;
my $Gui        = 0;

my $true       = 1;
my $false      = 0;
my $vol_label;
my $mute_button;
my $stn_play   = 5;
my $rb_label   = $Channel{$stn_play}[2];
my $radio_button;
my $rb_cb;
my $stn_slist;
my $mv_proc    = 0;
my $mply_proc  = 0;
my $xscr_proc  = 0;
my $pqiv_proc  = 0;
my $Pic_Dir    = "/mnt/backup/pictures";

#These variables are pretty global??
my (@flvcmd , @lamecmd ,@ffmpegcmd , @mp3spltcmd , @mplayercmd , @inoticmd , $PlayPath );
#Set Common Params
push ( @mplayercmd , ( '/usr/bin/mplayer' , '-cache' , '128' , -novideo , '-' ));

GetOptions (
	'channel=s'	=> \@SelChn,
	'find=s'	=> \@SelSer,
	'since=i'	=> \$SelSin,
	'outdir=s'	=> \$OutDir,
	'get'		=> \$get,
	'live'		=> \$live,
	'chunk=i'	=> \$chunk,
	'end=i'		=> \$stop,
	'play'		=> \$play,
	'gui'		=> \$Gui,
	'help|dump'	=> \$DmpChn,
) or die "Incorrect usage use --help for assistance.\n";

#print "DEBUG:: $OutDir\n";

if ( $DmpChn == 1 ) {
	print "List of channels: \n";
	foreach my $stn ( sort {$a <=> $b} ( keys %Channel )) {
		print "$stn live pid: $Channel{$stn}[0], AOD XML: $Channel{$stn}[1], Pretty Output: $Channel{$stn}[2]\n";
	}

print "\nUsage: ARGV[0] --live --channel x --chunk y --end z --outdir <dir> [--play]\n";
print "--live:    download the specified channel, chunk will
           split the file every y mins, end, stop after z mins
           (Requires flvstreamer, ffmpeg, lame and mp3splt)
--play:    will play it (requires mplayer), chunk is ignored
--channel: a single integer refers to bb channels. see --help for a list.\n";

print "\nUsage: ARGV[0] [--get] --channel x[,y,z] --since n --outdir <dir> --find <string> [--find <string> --find <string>]\n";
print "default:   search in specified channels for search string(s)
--since:   will result in only searching for files available in the last n hours
--get:     fetch the files (needs flvstreamer and ffmpeg)
--channel: comma seperated list of channels to search (--help for list)
--play:    attempt to play, does not seem to work (needs mplayer to not work)\n";
exit;
}
sub isitaPID {
	my $testpid = shift;
	my $pidlth  = 8;
	my $pidsrt  = 'b00';
	if ( length($testpid) == $pidlth ) {
		#print "DEBUG:: It might be a pid it's 8 characters\n";
		if ( $testpid =~ m/^$pidsrt/ ) {
			#print "DEBUG:: It might be a pid it starts with $pidsrt\n";
			return 1;
		} else {
			#print "DEBUG:: It not a PID";
			return 0;
		}
	} else {
		#print "DEBUG:: It not a PID\n";
		return 0;
	}
}

sub processMediaSelector {
	my $SelBase = "http://www.bbc.co.uk/mediaselector/4/mtis/stream/";
	my $MedPid = shift;
	my @StrTyp = @_;
	# read XML file
	my $ua = LWP::UserAgent->new;
	my $raw = $ua->request(HTTP::Request->new( GET => $SelBase . $MedPid ) );
	my $data = $xml->XMLin($raw->content);
	my $media_index = 0;
	my $serv_index = 0;
	until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( defined($data->{media}[$media_index]->{service}) == 0 ) ) {
		$serv_index = 0;
		until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( $serv_index >= $#StrTyp ) ) {
               	++$serv_index;
		}
		if ( $data->{media}[$media_index]->{service} ne $StrTyp[$serv_index] ) {
                	++$media_index;
        	}
	}
	#print "DEBUG:: which stream $StrTyp[$serv_index] \n";
	#print "DEBUG:: server should be $data->{media}[$media_index]->{connection}->{server}\n";
	#Initialise hash ....
	my %mattribs;
	my $fcsraw  = $ua->request(HTTP::Request->new( GET => "http://" . $data->{media}[$media_index]->{connection}->{server} . "/fcs/ident" ) );
	my $fcsdata = $xml->XMLin($fcsraw->content);
	%mattribs = (
		success     => 1,
		authString  => $data->{media}[$media_index]->{connection}->{authString},
		identifier  => $data->{media}[$media_index]->{connection}->{identifier},
		encoding    => $data->{media}[$media_index]->{encoding},
		server      => $data->{media}[$media_index]->{connection}->{server},
		application => $data->{media}[$media_index]->{connection}->{application},
		ip	    => $fcsdata->{ip},
	);
	return %mattribs;
}
	
sub streamStation {
	#print Dumper ( @_ );
	my $chan  = shift;
	if ( $chan =~ /^[+-]?\d+$/ ) {
		#print "DEBUG::channel $chan\n"
	} else {
		$chan = shift;
		#print "DEBUG::channel $chan\n"
	}
	my $show  = $Channel{$chan}[0];
	#print "DEBUG::show $show\n``";
	my $title = $Channel{$chan}[2];
	my @localtime = localtime(time);
	my $filetime = strftime("%Y%m%d_%H%M", @localtime);
	
	#This locks it to the low bandwidth iplayer flash stream
	#my @stream = ( "iplayer_uk_stream_aac_rtmp_lo_live" , "iplayer_uk_stream_aac_rtmp_live" );
	my @stream = ( "iplayer_uk_stream_aac_rtmp_live" , "iplayer_uk_stream_aac_rtmp_lo_live" );
	my %attribs = processMediaSelector ( $show , @stream );
	#this command may need to be in the loop, I think the auth will fail after a period.....
	@flvcmd = ();
	push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/live" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/live?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}?$attribs{authString}&aifp=v001" , '--live' , '--flv' , '-' ));
	if ( $play == 1 ) {
		if ( $stop != 0 ) {
				$stop = ($stop * 60);
        			push ( @flvcmd , ( '--stop' , "$stop" ) );
		}
		@ffmpegcmd = ();
                push ( @ffmpegcmd , ('/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , '-' , '-v' , '0' , '-vn' , '-f' , 'wav' , '-' ));
                $mply_proc = start \@flvcmd , '|' , \@mplayercmd;
		#print "DEBUG:: Do We see this????\n";
        } else {
		@ffmpegcmd = ();
                push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , '-i' , '-' , '-v' , '0' , '-vn' , '-f' , 'wav' , '-' ));
		my $counter = 1;
		my $runtot = 0;
                push ( @lamecmd , ( '/usr/bin/lame' , '--quiet' , '-a' , '-q', '7' , '--resample' , '44.1' , '-b' , '32' , '-' , "dummyname" ));
		if ( $stop != 0 ) {
			$stop = $stop * 60;
			$chunk = $chunk * 60;
			#push the default chunk length onto the end
		} else {
			#If they haven't specified a stop stop after 4hrs with no chunks
			$stop = 14400;
			$chunk = 14400;
		}
        		push ( @flvcmd , ( '--stop' , "$chunk"  ) );
		while ( $runtot < $stop ) {
			my $filename = "$filetime\_$counter\_$title.mp3";
			if ( ($stop - $runtot) < $chunk ) {
				$chunk = $stop - $runtot;
				pop ( @flvcmd );
        			push ( @flvcmd , "$chunk"  );
			}
			pop ( @lamecmd );
			push ( @lamecmd , ( "$tmpdir/$filename" ));
        	        run \@flvcmd , '|' , \@ffmpegcmd , '|' , \@lamecmd;
			my @mvcmd = ( '/bin/mv' , "$tmpdir/$filename" , "$OutDir/$filename" );
                        if ( $mv_proc != 0 ) {
                                finish $mv_proc;
                        }
                        $mv_proc = start \@mvcmd;
			$runtot = $runtot + $chunk;
				
			$counter = ++$counter;
		}
	}
}

sub stopStation {
	if ($mply_proc != 0){
		$mply_proc->kill_kill;
		kill_kill $mply_proc;
		finish $mply_proc;
	}
}

sub downloadPID {
	my @shows  = @_;
	my @stream = ( "iplayer_uk_stream_mp3" , "iplayer_intl_stream_mp3");
	#my @stream = ( "iplayer_uk_stream_mp3" );
	#print Dumper (@shows);
	my $show_index = 0;
	my %attribs;
	until ( $show_index == ($#shows+1) ) {
		#make the title safe
		my $title = $shows[$show_index][1];
		$title =~ tr/a-zA-Z0-9/_/c;
		$title = $title . '_' . $shows[$show_index][0];
		my $stream_index = 0;
		#print "DEBUG:: show pid $shows[$show_index][0] , stream id $stream[$stream_index]\n";
		my %attribs = processMediaSelector ( $shows[$show_index][0] , @stream );
		#Check if file exists and don't download if it does
		if ( -e "$OutDir/$title.$attribs{encoding}" ) {
			print "File $OutDir/$title.$attribs{encoding} Exists Do Not Download!!\n";
		} else {
			#print "will now download \n";
			@flvcmd = ();
        		push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '--resume' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/ondemand" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/ondemand?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}" ));
			if ( $play == 1 ) {
				push ( @flvcmd, '--flv' , '-' );
                		run \@flvcmd , '|' , \@mplayercmd;
			} else {
				push ( @flvcmd, '--flv' , "$tmpdir/$title.$attribs{encoding}" );
				run \@flvcmd;
				#print Dumper(@flvcmd);
				@ffmpegcmd = ();
				push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , '-i' , "$tmpdir/$title.$attribs{encoding}" , '-acodec' , 'copy' , "$OutDir/$title.$attribs{encoding}"  ));
				#print Dumper(@ffmpegcmd);
				run \@ffmpegcmd;
                		unlink "$tmpdir/$title.$attribs{encoding}";
			}
		}
		++$show_index;
	}
		
}

sub searchShow {
	my @SelPid   = ();
	my $AodBase  = "http://www.bbc.co.uk/radio/aod/availability/";
	my $SelSuff  = ".xml";
	my $search   = shift;
	my $since    = shift;
	my @channels = @_;
	my $now      = time();
	#isitaPID ($search);
	foreach my $station ( @channels ) {
		if (!defined($Channel{$station}[3])) {
			# read XML file
			my $ua = LWP::UserAgent->new;
			my $raw = $ua->request(HTTP::Request->new( GET => $AodBase . $Channel{$station}[1] . $SelSuff ) );
			#Push the XML out into the Channel hash, this saves exessive calls to the BBC website
			$Channel{$station}[3] = $xml->XMLin($raw->content, ForceArray => 'entry' );
		}
		my $entry_index = 0;
		my $data = \$Channel{$station}[3];
		#print "DEBUG:: $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}\n";
		until ( defined($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}) == 0 ) {
			if (( $$data->{entry}[$entry_index]->{title}[0] =~ /$search/i ) || ( $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid} eq $search )) {
				my $added = str2time($$data->{entry}[$entry_index]->{availability}[0]->{start});
				if ( ( $added >= $now - ( $since * 3600 )) && ( $added <= $now )) {
					my @TmpArray = ();
					#print "DEBUG:: ( $$data->{entry}[$entry_index]->{title}[0] $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}  $search \n";
					@TmpArray = ($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid},$$data->{entry}[$entry_index]->{title}[0],$$data->{entry}[$entry_index]->{availability}[0]->{start},$Channel{$station}[2]);
					push ( @SelPid, ( [@TmpArray] ) );
				}
			}
			++$entry_index;
		}
	}
	return @SelPid;
}

sub getvol {
	my $out;
	my @amcmd = ('/usr/bin/amixer' , 'get' , 'Master' );
	my @grcmd = ( '/bin/grep' , 'Front Left:' );
	run ( \@amcmd , '|' , \@grcmd , '>' , \$out ); 
	my @vol_array = split ( / +/ , $out );
	#print Dumper ( @vol_array );
	$vol_label->set_label("Vol: ". $vol_array[4] . "/ 31");
	if ( $vol_array[7]  =~ m/on/ ) {
		$mute_button->set_label("Mute Off");
		return ($vol_array[4] , $true);
	} else {
		$mute_button->set_label("Mute On");
		return ($vol_array[4] , $false);
	}
}


sub volume {
	shift;
	#print Dumper ( @_ );
	my $action = shift;
	my @vol_state = getvol;

	#print "DEBUG:: action $action";
	my @amcmd = ('/usr/bin/amixer' , '-q' , 'cset' );

	switch ($action) {

		case "mute" {
			 if ($vol_state[1] == $true) {
                                #print "unmute";
                                system ('/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Switch" off');
                        } else {
                                #print "mute";
                                system ('/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Switch" on');
                        }
		}
	
		case "up" {
			#print "vol up $vol_state[0]\n";
			system ( '/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Volume" '.++$vol_state[0] );
		}
		case "down" {
			#print "vol down $vol_state[0]\n";
			system ( '/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Volume" '.--$vol_state[0] );
		}
	}	
	getvol;
}

sub  ip_addr {
	my $junk = shift;
	my $request = shift;
	my $interface;
	my %IPs;

	foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        	$interface = $1 if /^(\S+?):?\s/;
        	next unless defined $interface;
        	$IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        	$IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
	}

	print Dumper(\%IPs);
	return $IPs{$interface}->{IP};
}

sub refresh_status {

#getvol;
#ip_addr;

}

sub controlStation {
	#This sub is called when the radio player is started or stopped it then sets the vars appropriately
	my $button  = shift;
	my $station = $_[0][0];
	my $action  = $_[0][1];

	#print "DEBUG:: $station station $action action \n";

	if ( $action eq "start" ) {
		streamStation $station;
		#if it returns assumed it worked may have to check if it failed.
		#disconnect the handler
		$radio_button->signal_handler_disconnect($rb_cb);
		#Change the label
		$radio_button->set_label("Stop Radio: $rb_label");
		$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play, "stop"] );
		#disable the list control 
		$stn_slist->sensitive($false);
	} else {
		stopStation $station;
		#if it returns assumed it worked may have to check if it failed.
		#disconnect the handler
		$radio_button->signal_handler_disconnect($rb_cb);
		#Change the label
		$radio_button->set_label("Play Radio: $rb_label");
		$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play, "start"] );
		$stn_slist->sensitive($true);
	
	}
}

sub start_slideshow {
	if ( $pqiv_proc != 0 ) {
		finish $pqiv_proc;
	}
	#set the backlight to max::
	system('/bin/echo 0 > /sys/class/backlight/openframe-bl/bl_power');
	my @pqivcmd = ( '/usr/bin/pqiv' , '-fsnnid' , '10' , "$Pic_Dir" ); 
	$pqiv_proc = start \@pqivcmd;
	system ('/usr/bin/killall xscreensaver');
	system ('/usr/bin/xset -dpms');
}

sub startGui {
	#Need to init, as the use if doesn't support init
	Gtk2->init;
	# If loading gui for now assume playing not saving
	$play = 1;
	# Create the window
	my $base_win = new Gtk2::Window( "toplevel" );
	$base_win->set_title( "RadioControl" );
	$base_win->signal_connect( "destroy", sub { 
		stopStation;
		Gtk2->main_quit; });
	$base_win->set_border_width( 10 );

	# Create the main vertical box.
	my $base_vbox = new Gtk2::VBox( $false, $false );
	$base_win->add( $base_vbox );

	# Create a horizontal frame
	my $base_frame = new Gtk2::Frame( "JoggControl" );
	$base_vbox->pack_start( $base_frame, $true, $true, 10 );

	my $sub_hbox = new Gtk2::HBox( $false, $false );
	$base_vbox->pack_start( $sub_hbox, $true, $true, 10 );

	my $hbbox = new Gtk2::HButtonBox();
	$hbbox->set_border_width( 5 );
	$hbbox->set_layout( "spread" );
	$hbbox->set_spacing( 10 );

	my $ss_button = new Gtk2::Button( "SlideShow" );
	$ss_button->signal_connect('clicked' => \&start_slideshow );
	$hbbox->add( $ss_button );

	my $volup_button = new Gtk2::Button( "Vol Up" );
	$volup_button->signal_connect('clicked' => \&volume , "up" );
	$hbbox->add( $volup_button );

	my $voldn_button = new Gtk2::Button( "Vol Dn" );
	$voldn_button->signal_connect('clicked' => \&volume , "down" );
	$hbbox->add( $voldn_button );

	$vol_label = new Gtk2::Label ( "Vol: ?? / 31" );
	$hbbox->add( $vol_label );

	$mute_button = new Gtk2::Button( "Mute" );
	$mute_button->signal_connect('clicked' => \&volume , "mute" );
	$hbbox->add( $mute_button );
	
	#Initialise the volume levels
	getvol;

	my $exit_button = new Gtk2::Button( "Exit" );
	$exit_button->signal_connect('clicked' => sub { $base_win->destroy });
	$hbbox->add( $exit_button );

	$base_frame->add( $hbbox );



	my $left_vframe = new Gtk2::Frame( "Radio Select" );
	my $mid_vframe = new Gtk2::Frame( "Radio Control" );
	my $right_vframe = new Gtk2::Frame( "Status and Info" );

	$sub_hbox->pack_start($left_vframe, $true, $true, 10);
	$sub_hbox->pack_start($mid_vframe, $true, $true, 10);
	$sub_hbox->pack_start($right_vframe, $true, $true, 10);

	my $mid_vbbox = new Gtk2::VButtonBox();
	$mid_vbbox->set_border_width( 5 );
	$mid_vframe->add( $mid_vbbox );
	#$mid_vbbox->set_layout( "spread" );
	$mid_vbbox->set_spacing( 30 );

	my $temp_button = new Gtk2::Button( "Stop Radio: $Channel{$stn_play}[2]" );
	$temp_button->signal_connect('clicked' => \&stopStation, $stn_play );
	$mid_vbbox->add( $temp_button );
	$radio_button = new Gtk2::Button( "Play Radio: $Channel{$stn_play}[2]" );
	#$radio_button->set_width_chars(10);
	$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play , "start"] );
	#$left_vbbox->add( $radio_button );

	my $left_vbox = new Gtk2::VBox( $false, 0 );
	$left_vframe->add ($left_vbox);
	$stn_slist = Gtk2::SimpleList->new  (
		'ID'	  => 'int',
		'Name'	  => 'text',
        );
        #@{$stn_slist->{data}} = %Channel;
	foreach my $stn ( sort {$a <=> $b} ( keys %Channel )) {
		#print "DEBUG:: $stn $Channel{$stn}[2] \n";
		push  (@{$stn_slist->{data}} , ( [$stn, $Channel{$stn}[2]] ));
	}
        $left_vbox->pack_start($stn_slist, $true, $true, 10 );
	$left_vbox->pack_start($radio_button, $true, $true, 10);

        $stn_slist->get_selection->signal_connect ( changed => sub {
                my ($selection) = @_;
                my $stn_slist = $selection->get_tree_view;
                my ($sel) = $stn_slist->get_selected_indices;
                $stn_play = $stn_slist->{data}[$sel][0];
		$rb_label = $stn_slist->{data}[$sel][1];
		$radio_button->set_label("Play Radio: $rb_label");
		#Disconnect the button callback
		$radio_button->signal_handler_disconnect($rb_cb);
		#reconnect callback handler here, because the value seems to be static
		$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play ,"start"] );
        });



	my $choose_button = Gtk2::FileChooserButton->new('Select Mp3' , 'open' );
	$choose_button->set_width_chars(10);
        $left_vbox->pack_start($choose_button, $true, $true, 10 );

	my $right_vbbox = new Gtk2::VButtonBox();
	$right_vbbox->set_border_width( 5 );
	$right_vframe->add( $right_vbbox );
	#$right_vbbox->set_layout( "spread" );
	$right_vbbox->set_spacing( 10 );
	my $wlan_label = new Gtk2::Label ( "wlan0 IP Address:" );
	$right_vbbox->add( $wlan_label );
	my $wlan_ip = ip_addr 'wlan0';
	my $wlan_addr = new Gtk2::Label ( $wlan_ip );
	$right_vbbox->add( $wlan_addr );
	my $eth_label = new Gtk2::Label ( "eth0 IP Address:" );
	$right_vbbox->add( $eth_label );
	my $eth_ip = ip_addr 'eth0';
	my $eth_addr = new Gtk2::Label ( $eth_ip );
	$right_vbbox->add( $eth_addr );

	my $refresh_button = new Gtk2::Button( "_Refresh" );
	$refresh_button->signal_connect('clicked' => \&refresh_status );
	$right_vbbox->add( $refresh_button );

	$base_win->show_all;
	Gtk2->main;

}


#Main Code starts here
#Always convert the channel to an array (needs error checking)#
#For a live stream only use the first one
@SelChn = split(/,/,join(',',@SelChn));
#If its live we can bypass the search part and jump straight to the streaming

if ( $Gui  == 1 ) {
	#print ("load gui");
	startGui
} elsif ( $live == 1 ) {
	#print "\nDEBUG:: in main streamStation $SelChn[0] \n";
	streamStation ( $SelChn[0] );
} else {
	my @Results = ();
	foreach my $look (@SelSer) {
		push ( @Results  , (searchShow ( $look , $SelSin , @SelChn )));
	}
		if ( $get == 1 ) {
			#print "calling downloadPID \n";
			downloadPID (@Results);
		} else {
			print Dumper (@Results);
		}
}
