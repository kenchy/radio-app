#!/usr/bin/perl -w
#get_radio V0.16
#works in all meaningful ways
#Allows multiple searches and channels for program downloading
#Caches the XML for the AOD pages so that the file is only pulled once
#Has a crude mechanism for identifying pids UNUSED
#Matches a program based on a regex of the title or the PID
#TODO:
#Error trapping:
#Spot when a media selector URL doesn't return data
#Get cleverer about matching the live stream currently --live will turn off other methods


# use module
use strict;
use Getopt::Long;
use Date::Format;
use Date::Parse;
#use XML::Simple qw(:strict);
use XML::Simple;
use Data::Dumper;
use Switch;
use HTTP::Request;
use LWP::UserAgent;
use IPC::Run qw( run start pump );
use File::Copy;
use threads;
use if defined $ENV{DISPLAY} , "Gtk2";
use if defined $ENV{DISPLAY} , "Gtk2::SimpleList";
#use if defined $ENV{DISPLAY} , "Gnome2::Wnck";
# create object
my $xml = new XML::Simple;

#Some Vars
#inoticoming doesn't work with a station name that starts with a number
my %Channel = (
		1  => [ "bbc_radio_one"       		   , "radio1"        , "Radio1" ],
		2  => [ "bbc_radio_two"       	       	   , "radio2"        , "Radio2" ],
		3  => [ "bbc_radio_three"     		   , "radio3"        , "Radio3" ],
		4  => [ "bbc_radio_four"	      	   , "radio4"        , "Radio4" ],
		5  => [ "bbc_radio_five_live" 		   , "fivelive"      , "R5live"  ],
		6  => [ "bbc_6music"                       , "6music"        , "R6music" ],
		7  => [ "bbc_7"               		   , "bbc7"          , "BBC7" ],
		8  => [ "bbc_radio_five_live_sports_extra" , "sportsextra"   , "R5LSX" ],
                10 => [ "bbc_radio_wales_fm"               , "radiowales"    , "R.Wales" ],
                11 => [ "bbc_radio_scotland_fm"            , "radioscotland" , "R.Scot" ],
                12 => [ "bbc_world_service"                , "worldservice"  , "BBC_WS" ],
                20 => [ "bbc_wm"                           , "bbc_wm"        , "RadioWM" ],
);

my @SelChn     = ();
my @SelSer     = ();
my $SelSin     = 350;
my $DmpChn     = 0;
my $OutDir     = $ENV{HOME} || (getpwuid($<))[7] || '/tmp' ;
my $tmpdir     = '/tmp';
my $live       = 0;
my $rawlive    = 0;
my $chunk      = 30;
my $stop       = 180;
my $play       = 0;
my $skip       = 0;
my $recode     = 0;
my $dirchunk    = 0;
my $get	       = 0;
my $MaxPids    = 5;
my $FlvPrt     = 1935;
my $Gui        = 0;
my $true       = 1;
my $false      = 0;
my $vol_label;
my $mute_button;
my $stn_play   = 5;
my $rb_label   = $Channel{$stn_play}[2];
my $radio_button;
my $rb_cb;
my $mid_vbbox;
my $sr_button;
my $sr_cb;
my $stn_slist;
my $res_slist;
my $kb_proc    = 0;
my $base_win;
my $entry;
my $eth_addr;
my $wlan_addr;
my $mply_proc  = 0;
my $xscr_proc  = 0;
my $pqiv_proc  = 0;
my $Pic_Dir    = "/mnt/backup/pictures";
my $Title      = "Default Title String";
my $DrtPID = "";
my @gui_res;
my $out_suffix;

#These variables are pretty global??
my (@flvcmd , @lamecmd ,@ffmpegcmd , @mp3spltcmd , @mplayercmd , @inoticmd , $PlayPath );
#Set Common Params

GetOptions (
	'channel=s'	=> \@SelChn,
	'find=s'	=> \@SelSer,
	'since=i'	=> \$SelSin,
	'outdir=s'	=> \$OutDir,
	'get'		=> \$get,
	'live'		=> \$live,
	'rawlive'	=> \$rawlive,
	'chunk=i'	=> \$chunk,
	'end=i'		=> \$stop,
	'play'		=> \$play,
	'gui'		=> \$Gui,
	'help|dump'	=> \$DmpChn,
	'slide'		=> \$Pic_Dir,
	'dumppid=s'	=> \$DrtPID,
	'title=s'	=> \$Title,
	'recode'	=> \$recode,
	'dirchunk'	=> \$dirchunk,
	'skip=i'	=> \$skip
) or die "Incorrect usage use --help for assistance.\n";


if ( $DmpChn == 1 ) {
	print "List of channels: \n";
	foreach my $stn ( sort {$a <=> $b} ( keys %Channel )) {
		print "$stn : $Channel{$stn}[0], AOD XML: $Channel{$stn}[1], Pretty Output: $Channel{$stn}[2]\n";
	}

print "\nUsage: $0 --live --channel x --chunk y --end z --outdir <dir> [--play] -\n";
print "--live:    download the specified channel, chunk will
           split the file every y mins, end, stop after z mins
           (Requires flvstreamer, ffmpeg, and lame)
--rawlive: download the aac stream, and use ffmpeg to copy it to an mp4 container
           (very low CPU, ffmpeg seems to generate slightly iffy files)
--play:    will play it (requires mplayer), chunk is ignored
--channel: a single integer refers to bb channels. see --help for a list.\n";

print "\nUsage: $0 [--get] --channel x[,y,z] --since n --outdir <dir> --find <string> [--find <string> --find <string>]\n";
print "default:   search in specified channels for search string(s)
--since:   will result in only searching for files available in the last n hours
--get:     fetch the files (needs flvstreamer and ffmpeg)
--channel: comma seperated list of channels to search (--help for list)
--play:    attempt to play, does not seem to work (needs mplayer to not work)
--skip:    send a -A option to flvstreamer num of seconds\n";

print "\nUsage: $0 --gui 
--gui:	   load gui for live radio streaming (accepts no other options).\n";
exit;
}
sub isitaPID {
	my $testpid = shift;
	my $pidlth  = 8;
	my $pidsrtre  = '[pb]00';
	if ( length($testpid) == $pidlth ) {
		print "DEBUG:: It might be a pid it's 8 characters\n";
		if ( $testpid =~ m/^$pidsrtre/ ) {
			#print "DEBUG:: It might be a pid it starts with $pidsrtre\n";
			return 1;
		} else {
			#print "DEBUG:: It not a PID";
			return 0;
		}
	} else {
		#print "DEBUG:: It not a PID\n";
		return 0;
	}
}

sub processMediaSelector {
	my $SelBase = "http://www.bbc.co.uk/mediaselector/4/mtis/stream/";
	my $MedPid = shift;
	my @StrTyp = @_;
	# read XML file
	my $ua = LWP::UserAgent->new;
	my $raw = $ua->request(HTTP::Request->new( GET => $SelBase . $MedPid ) );
	my $data = $xml->XMLin(($raw->content), forcearray => [ 'media','connection' ]);
	my $media_index = 0;
	my $serv_index = 0;
	print "DEBUG:: number of medias $#{ $data->{media} } \n";
	#print Dumper ( $data );
	until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( defined($data->{media}[$media_index]->{service}) == 0 ) ) {
		#print "DEBUG:: return service is $data->{media}[$media_index]->{service}\n";
		#print "DEBUG:: match  service is $StrTyp[$serv_index]\n";
		$media_index = 0;
		#until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( $serv_index >= $#StrTyp ) ) {
		until ( ( $data->{media}[$media_index]->{service} eq $StrTyp[$serv_index] ) or ( $media_index >= $#{ $data->{media} } ) ) {
               		++$media_index;
			#print "DEBUG:: media index $media_index \n";
			#sleep 2;
		}
		if ( $data->{media}[$media_index]->{service} ne $StrTyp[$serv_index] ) {
			#print "DEBUG:: serv index $serv_index \n";
                	++$serv_index;
        	}
		#sleep 2;
	}
	#Right to do the lo lime light has to connections, look for the one that has protocol=rtmp
	#print "DEBUG:: which stream $StrTyp[$serv_index] \n";
        my $connection_index = 0;
	if ( $data->{media}[$media_index]->{connection}[$connection_index]->{protocol} ne "rtmp" ) {
		++$connection_index;
	}
	#print "DEBUG:: server should be $data->{media}[$media_index]->{connection}->{server}\n";
	#Initialise hash ....
	my %mattribs;
	my $fcsraw  = $ua->request(HTTP::Request->new( GET => "http://" . $data->{media}[$media_index]->{connection}[$connection_index]->{server} . "/fcs/ident" ) );
	my $fcsdata = $xml->XMLin($fcsraw->content);
	%mattribs = (
		success     => 1,
		authString  => $data->{media}[$media_index]->{connection}[$connection_index]->{authString},
		authExpires => $data->{media}[$media_index]->{connection}[$connection_index]->{authExpires},
		identifier  => $data->{media}[$media_index]->{connection}[$connection_index]->{identifier},
		encoding    => $data->{media}[$media_index]->{encoding},
		server      => $data->{media}[$media_index]->{connection}[$connection_index]->{server},
		application => $data->{media}[$media_index]->{connection}[$connection_index]->{application},
		kind	    => $data->{media}[$media_index]->{connection}[$connection_index]->{kind},
		ip	    => $fcsdata->{ip},
		stream	    => $StrTyp[$serv_index],
	);
	return %mattribs;
}
	
sub streamStation {
	#print Dumper ( @_ );
	my $chan  = shift;
  	my $starttime=time();
        my $finishtime=($starttime + (( $stop - 3 ) * 60));
	if ( $chan =~ /^[+-]?\d+$/ ) {
		#print "DEBUG::channel $chan\n"
	} else {
		$chan = shift;
		#print "DEBUG::channel $chan\n"
	}
	my $show  = $Channel{$chan}[0];
	#print "DEBUG::show $show\n``";
	my $title = $Channel{$chan}[2];
	my @localtime = localtime(time);
	my $filetime = strftime("%Y%m%d_%H%M", @localtime);
	
	#This locks it to the low bandwidth iplayer flash stream
	my @stream = ( "iplayer_uk_stream_aac_rtmp_lo_live" , "iplayer_uk_stream_aac_rtmp_live" , "iplayer_intl_stream_aac_rtmp_ws_live" );
	#my @stream = ( "iplayer_uk_stream_aac_rtmp_live" , "iplayer_uk_stream_aac_rtmp_lo_live" );
	my %attribs = processMediaSelector ( $show , @stream );
	if ( $play == 1 ) {
		@flvcmd = ();
		push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/live" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/live?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}?$attribs{authString}&aifp=v001" , '--live' , '--flv' , '-' ));
		if ( $stop != 0 ) {
				$stop = ($stop * 60);
        			push ( @flvcmd , ( '--stop' , "$stop" ) );
		}
		@mplayercmd = ();
		push ( @mplayercmd , ( '/usr/bin/mplayer' , -novideo , '-' , '-input' , 'file=/tmp/mplayer.fifo' , '-cache' , '512' ) );
                $mply_proc = start \@flvcmd , '|' , \@mplayercmd;
		#print "DEBUG:: Do We see this????\n";
        } else {
		my $file_suffix;
		@ffmpegcmd = ();
		if ($rawlive == 0){
                	push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' ,'quiet' , '-i' , '-' , '-v' , '0' , '-vn' , '-f' , 'wav' , '-' ));
                	push ( @lamecmd , ( '/usr/bin/lame' , '--quiet' , '-a' , '-q', '7' , '--resample' , '44.1' , '-b' , '32' , '-' , "dummyname" ));
			$file_suffix = "mp3";
		} else {
			$file_suffix = "m4a";
		}
	
		my $counter = 1;
		my $runtot = 0;
		if ( $stop != 0 ) {
			$stop = $stop * 60;
			$chunk = $chunk * 60;
			#push the default chunk length onto the end
		} else {
			#If they haven't specified a stop stop after 4hrs with no chunks
			$stop = 14400;
			$chunk = 14400;
		}
			#Push the initial values into the flvstreamed. This will be periodically refreshed...
			@flvcmd = ();
			push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/$attribs{application}" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/$attribs{application}?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}?$attribs{authString}&aifp=v001" , '--live' , '--flv' , '-' , '--stop' , "$chunk" ));
		#initialise the thread variable
		my $live_thread = 0;
		while ( $runtot < $stop ) {
			my $filename = "$filetime\_$counter\_$title.$file_suffix";
			my $flvname = "$filetime\_$counter\_$title.aac";
			if ((($stop - $runtot) < $chunk )&&( time() > $finishtime)) {
				$chunk = $stop - $runtot;
				pop ( @flvcmd );
        			push ( @flvcmd , "$chunk"  );
			}
			if ( $rawlive == 0 ) {
				pop ( @lamecmd );
				push ( @lamecmd , ( "$tmpdir/$filename" ));
        	        	my $test_harness = start \@flvcmd , '|' , \@ffmpegcmd , '|' , \@lamecmd;
				pump $test_harness;
				$test_harness->finish;
				if ($test_harness->full_result(0) > 0) {
					#we had an flv failure add a chunk on
					$stop = $stop + $chunk;
					print "FAILURE ALERT FAILURE ALERT \n";
				}
			} else {
				$flvcmd[10] = "$tmpdir/$flvname";
        	        	run \@flvcmd;
			}
			$runtot = $runtot + $chunk;
			$counter = ++$counter;
			if ( $live_thread != 0 ) {
				my $attribs = $live_thread->join;
				%attribs = %$attribs;
				@flvcmd = ();
				push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/$attribs{application}" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/$attribs{application}?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}?$attribs{authString}&aifp=v001" , '--live' , '--flv' , '-' , '--stop' , "$chunk" ));
			}
			#print "RETURNED ATTRIBS HERE\n";
			print "EXPIRES: $attribs{authExpires}\n";
			#print "STREAM:  $attribs{stream}\n";
			#print "IDENT:   $attribs{identifier}\n";
			$live_thread = threads->create(\&refreshFlv, $filename, $flvname, $rawlive, $show, @stream);	
		}
		if ($live_thread != 0 ){
			$live_thread->join;
		}
	}
}

sub refreshFlv {
	my $tfile    = shift;
	my $tflv     = shift;
	my $traw     = shift;
	my $tchan    = shift;
	my @tstreams = @_;
	if ( $traw == 0 ) { 
		my @mvcmd = ( '/bin/mv' , "$tmpdir/$tfile" , "$OutDir/$tfile" );
		run \@mvcmd;
	} else {
		my @ffmpeg = ();
        	push ( @ffmpeg , ( '/usr/bin/ffmpeg' , '-loglevel' ,'quiet' , '-i' , "$tmpdir/$tflv" , '-v' , '0' , '-vn' , '-metadata' , 'mimeType=audio/aac' , '-acodec' , 'copy' , "$OutDir/$tfile" ));
		my $return;
		$return = run \@ffmpeg;
		#Only delete the original if there are no ffmpeg errors
		if ( $return == 1 ){
			my @rmcmd = ( '/bin/rm' , "$tmpdir/$tflv" );
			run \@rmcmd;
		}
	}
	my %tattribs = processMediaSelector ( $tchan , @tstreams );
	#print Dumper %tattribs;
	return \%tattribs;
}

sub stopStation {
	if ($mply_proc != 0){
		$mply_proc->kill_kill;
		kill_kill $mply_proc;
		finish $mply_proc;
		$mply_proc = 0;
	}
}

sub downloadPID {
	my @shows  = @_;
	my @stream = ( "iplayer_uk_stream_mp3" , "iplayer_intl_stream_mp3" , "iplayer_intl_stream_mp3_lo" , "iplayer_uk_stream_aac_rtmp_lo_concrete" , "iplayer_intl_stream_aac_ws_concrete" , "iplayer_uk_stream_aac_rtmp_concrete" );
	#my @stream = ( "iplayer_uk_stream_aac_rtmp_lo_concrete" );
	#print Dumper (@shows);
	my $show_index = 0;
	my %attribs;
	until ( $show_index == ($#shows+1) ) {
		my $duration = $shows[$show_index][4];
		#check if we should chunk
		print "DEBUG::Duration $duration\n";
		#make the title safe
		my $title = $shows[$show_index][1];
		$title =~ tr/a-zA-Z0-9/_/c;
		$title = $title . '_' . $shows[$show_index][0];
		my $stream_index = 0;
		#print "DEBUG:: show pid $shows[$show_index][0] , stream id $stream[$stream_index]\n";
		my %attribs = processMediaSelector ( $shows[$show_index][0] , @stream );
		#Check if file exists and don't download if it does
		#hack to catch m4a.....
		#if ( ( -e "$OutDir/$title.$attribs{encoding}"  ) or ( -e "$OutDir/$title.m4a" ) ) {
		if ( ( -e "$OutDir/$title.mp3"  ) or ( -e "$OutDir/$title.m4a" ) or ( -e "$OutDir/$title" ) ) {
			print "File $OutDir/$title.$attribs{encoding} or $OutDir/$title.m4a or $OutDir/$title Exists Do Not Download!!\n";
		} else {
			#print "will now download \n";
			@flvcmd = ();
			if ( $attribs{kind} eq "akamai" ) {
        			#push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '--resume' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/ondemand" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/ondemand?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}" ));
        			push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '--resume' , '-r' , "rtmp://$attribs{ip}:$FlvPrt/$attribs{application}" , '-t' , "rtmp://$attribs{ip}:$FlvPrt/$attribs{application}?_fcs_vhost=$attribs{server}&$attribs{authString}" , '--playpath' , "$attribs{identifier}" ));
			} else {
        			push ( @flvcmd , ( '/usr/bin/flvstreamer' , '-q' , '--protocol' , '0', '--resume' , '--host' , "$attribs{server}" , '-a' , "$attribs{application}?$attribs{authString}" , '-y' , "$attribs{identifier}" ));
			}
			my $out_title = $title;
			if (( $skip > 0 ) && ( $dirchunk == 0 )) {
				#this copes with skip if not dir chunking, incorporate skip into dirchunk section
				push ( @flvcmd , ( '-A' , "$skip" ));
				$out_title = $title."_skipped_".$skip;
			}
			if ( $play == 1 ) {
				@mplayercmd = ();
				push ( @mplayercmd , ( '/usr/bin/mplayer' , -novideo , '-' , '-input' , 'file=/tmp/mplayer.fifo' , '-cache' , '8192' ) );
				push ( @flvcmd, '--flv' , '-' );
                		$mply_proc = start \@flvcmd , '|' , \@mplayercmd;
			} else {
				if ( $dirchunk == 1 ) {
					mkdir "$OutDir/$title";
					my $chnk = 900;
					my $chnkstrt;
					if ( $skip > 0 ) {
						$chnkstrt = $skip;
					} else {
						$chnkstrt = 0;
					}
					my $chnkfin = 0;
					my $tmptitle;
					my $chnkindex = 1;
					until ( $chnkfin >= $duration ) {
						$chnkfin  = $chnkstrt + $chnk;
						$tmptitle = sprintf("%02d", $chnkindex)."_".$title;
						#$tmptitle = $chnkstrt.$shows[$show_index][0];
						push ( @flvcmd , ( '-A' , "$chnkstrt" , '-B' , "$chnkfin" , '--flv' , "$tmpdir/$tmptitle.$attribs{encoding}" ) );
						#print Dumper (@flvcmd);
						run \@flvcmd;
						@ffmpegcmd = ();
						#quick hack, if it's an aac output as m4a
						if ( $attribs{encoding} =~ "aac" ) {	
							if ( $recode == 1 ) {
								$out_suffix = "mp3";
								push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , "$tmpdir/$tmptitle.$attribs{encoding}" , '-acodec' , 'libmp3lame' , '-ab' , '48k' , "$OutDir/$out_title/$tmptitle.$out_suffix"  ));
							} else { 	
								$out_suffix = "m4a";
								push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , "$tmpdir/$tmptitle.$attribs{encoding}" , '-f' , 'mp4' , '-acodec' , 'copy' , '-vn' , "$OutDir/$out_title/$tmptitle.$out_suffix"  ));
							}
						} else {
							$out_suffix = "mp3";
							push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , "$tmpdir/$title.$attribs{encoding}" , '-acodec' , 'copy' , "$OutDir/$out_title.$out_suffix"  ));
						}
						run \@ffmpegcmd;
                				unlink "$tmpdir/$tmptitle.$attribs{encoding}";
						$chnkstrt = $chnkfin;
						++$chnkindex;
						pop (@flvcmd);
						pop (@flvcmd);
						pop (@flvcmd);
						pop (@flvcmd);
						pop (@flvcmd);
						pop (@flvcmd);
					}
				} else {
					push ( @flvcmd, '--flv' , "$tmpdir/$title.$attribs{encoding}" );
					run \@flvcmd;
					#print Dumper(@flvcmd);
					@ffmpegcmd = ();
					#quick hack, if it's an aac output as m4a
					if ( $attribs{encoding} =~ "aac" ) {	
						if ( $recode == 1 ) {
							$out_suffix = "mp3";
							push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , "$tmpdir/$title.$attribs{encoding}" , '-acodec' , 'libmp3lame' , '-ab' , '48k' , "$OutDir/$out_title.$out_suffix"  ));
						} else { 
							$out_suffix = "m4a";
							push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , "$tmpdir/$title.$attribs{encoding}" , '-f' , 'mp4' , '-acodec' , 'copy' , '-vn' , "$OutDir/$out_title.$out_suffix"  ));
						}
					} else {
						$out_suffix = "mp3";
						push ( @ffmpegcmd , ( '/usr/bin/ffmpeg' , '-loglevel' , 'quiet' , '-i' , "$tmpdir/$title.$attribs{encoding}" , '-acodec' , 'copy' , "$OutDir/$out_title.$out_suffix"  ));
					}
					run \@ffmpegcmd;
                			unlink "$tmpdir/$title.$attribs{encoding}";
				}
			}
		}
		++$show_index;
	}
		
}

sub searchShow {
	my @SelPid   = ();
	my $AodBase  = "http://www.bbc.co.uk/radio/aod/availability/";
	my $SelSuff  = ".xml";
	my $search   = shift;
	my $since    = shift;
	my @channels = @_;
	my $now      = time();
	#print "searcgh $search since $since channels";
	#print Dumper (@channels); 
	#isitaPID ($search);
	foreach my $station ( @channels ) {
		if (!defined($Channel{$station}[3])) {
			# read XML file
			my $ua = LWP::UserAgent->new;
			my $raw = $ua->request(HTTP::Request->new( GET => $AodBase . $Channel{$station}[1] . $SelSuff ) );
			#Push the XML out into the Channel hash, this saves exessive calls to the BBC website
			$Channel{$station}[3] = $xml->XMLin($raw->content, ForceArray => 'entry' );
		}
		my $entry_index = 0;
		my $data = \$Channel{$station}[3];
		#print "DEBUG:: $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}\n";
		until ( defined($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}) == 0 ) {
			if (( $$data->{entry}[$entry_index]->{title}[0] =~ /$search/i ) || ( $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid} eq $search )) {
				my $added = str2time($$data->{entry}[$entry_index]->{availability}[0]->{start});
				if ( ( $added >= $now - ( $since * 3600 )) && ( $added <= $now )) {
					my @TmpArray = ();
					#print "DEBUG:: ( $$data->{entry}[$entry_index]->{title}[0] $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}  $search \n";
					@TmpArray = ($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid},$$data->{entry}[$entry_index]->{title}[0],$$data->{entry}[$entry_index]->{availability}[0]->{start},$Channel{$station}[2],$$data->{entry}[$entry_index]->{broadcast}[0]->{duration});
					push ( @SelPid, ( [@TmpArray] ) );
				}
			}
			++$entry_index;
		}
	}
	return @SelPid;
}

sub searchFeeds {
        my @SelPid   = ();
        #my $AodBase  = "http://www.bbc.co.uk/radio/aod/availability/";
        my $FeedBase  = "http://feeds.bbc.co.uk/iplayer/";
	my $FeedSuff  = "/list/";
        my $pidBase  = "http://www.bbc.co.uk/iplayer/playlist/";
        my $SelSuff  = ".xml";
        my $search   = shift;
        my $since    = shift;
        my @channels = @_;
        my $now      = time();
        #print "search $search since $since channels";
        #print Dumper (@channels);
        #isitaPID ($search);
        foreach my $station ( @channels ) {
                if (!defined($Channel{$station}[3])) {
                        # read XML file
                        my $ua = LWP::UserAgent->new;
			print $FeedBase . $Channel{$station}[0] . $FeedSuff . "\n";
                        my $raw = $ua->request(HTTP::Request->new( GET => $FeedBase . $Channel{$station}[0] . $FeedSuff ) );
                        #Push the XML out into the Channel hash, this saves exessive calls to the BBC website
                        $Channel{$station}[3] = $xml->XMLin($raw->content, ForceArray => 'entry' );
			#print Dumper ( $Channel{$station}[3] );
                }
                my $entry_index = 0;
                my $data = \$Channel{$station}[3];
                #print "DEBUG:: $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}\n";
                until ( defined($$data->{entry}[$entry_index]->{id}[0]) == 0 ) {
			#need the broadcast pid... get it here
			my @id = split(/:/, $$data->{entry}[$entry_index]->{id}[0]);
			#print "DEBUG:: $id[3]\n";
			#print Dumper ( $$data->{entry}[$entry_index]->{content}->{content} );
			#print Dumper ( $$data->{entry}[$entry_index]->{title}[0]->{content} );
			#print "$$data->{entry}[$entry_index]->{updated}[0] \n" ;
                        if (( $$data->{entry}[$entry_index]->{title}[0]->{content} =~ /$search/i ) || ( $id[3] eq $search )) {
				#print Dumper ( $$data->{entry}[$entry_index]->{title}[0]->{content} );
				#print Dumper ( $$data->{entry}[$entry_index]->{updated}[0] );
                                my $added = str2time($$data->{entry}[$entry_index]->{updated}[0]);
                                if ( ( $added >= $now - ( $since * 3600 )) && ( $added <= $now )) {
                        		my $progua = LWP::UserAgent->new;
					my $prograw = $progua->request(HTTP::Request->new( GET => $pidBase . $id[3] ) );
					my $progdata = $xml->XMLin($prograw->content, ForceArray => 'entry' );
					#print Dumper ( $progdata );
					#print Dumper ( $$progdata->{item}[0]->{duration} );
					#print Dumper ( $progdata->{item});
                                        my @TmpArray = ();
                                        #print "DEBUG:: ( $$data->{entry}[$entry_index]->{title}[0] $$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid}  $search \n";
                                        #@TmpArray = ($$data->{entry}[$entry_index]->{broadcast}[0]->{version_pid},$$data->{entry}[$entry_index]->{title}[0],$$data->{entry}[$entry_index]->{availability}[0]->{start},$Channel{$station}[2],$$data->{entry}[$entry_index]->{broadcast}[0]->{duration});
                                        @TmpArray = ($progdata->{item}[0]->{identifier},$$data->{entry}[$entry_index]->{title}[0]->{content},$$data->{entry}[$entry_index]->{updated}[0],$Channel{$station}[2],$progdata->{item}[0]->{duration},$progdata->{summary}[0], $id[3] );
                                        push ( @SelPid, ( [@TmpArray] ) );
                                }
                        }
                        ++$entry_index;
        	}
	}
        return @SelPid;
}

sub getvol {
	my $out;
	my @amcmd = ('/usr/bin/amixer' , 'get' , 'Master' );
	my @grcmd = ( '/bin/grep' , 'Front Left:' );
	run ( \@amcmd , '|' , \@grcmd , '>' , \$out ); 
	my @vol_array = split ( / +/ , $out );
	#print Dumper ( @vol_array );
	$vol_label->set_label("Vol: ". $vol_array[4] . "/ 31");
	if ( $vol_array[7]  =~ m/on/ ) {
		$mute_button->set_label("Mute Off");
		return ($vol_array[4] , $true);
	} else {
		$mute_button->set_label("Mute On");
		return ($vol_array[4] , $false);
	}
}


sub volume {
	shift;
	#print Dumper ( @_ );
	my $action = shift;
	my @vol_state = getvol;

	#print "DEBUG:: action $action";
	my @amcmd = ('/usr/bin/amixer' , '-q' , 'cset' );

	switch ($action) {

		case "mute" {
			 if ($vol_state[1] == $true) {
                                #print "unmute";
                                system ('/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Switch" off');
                        } else {
                                #print "mute";
                                system ('/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Switch" on');
                        }
		}
	
		case "up" {
			#print "vol up $vol_state[0]\n";
			system ( '/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Volume" '.++$vol_state[0] );
		}
		case "down" {
			#print "vol down $vol_state[0]\n";
			system ( '/usr/bin/amixer -q cset iface=MIXER,name="Master Playback Volume" '.--$vol_state[0] );
		}
	}	
	getvol;
}

sub  ip_addr {
	#my $junk = shift;
	my $request = shift;
	my $interface;
	my %IPs;

	foreach ( qx{ (LC_ALL=C /sbin/ifconfig -a 2>&1) } ) {
        	$interface = $1 if /^(\S+?):?\s/;
        	next unless defined $interface;
        	$IPs{$interface}->{STATE}=uc($1) if /\b(up|down)\b/i;
        	$IPs{$interface}->{IP}=$1 if /inet\D+(\d+\.\d+\.\d+\.\d+)/i;
	}

	#print Dumper(\%IPs);
	#print "request is $request";
	if ( defined $IPs{$request}->{IP} ) {
		return $IPs{$request}->{IP};
	} else {
		return "NO_IP";
	}
}

sub refresh_status {

#getvol;
#ip_addr;
#$eth_ip = ip_addr 'eth0';
$wlan_addr->set_label( ip_addr 'wlan0' );
$eth_addr->set_label( ip_addr 'eth0' );

}

sub controlStation {
	#This sub is called when the radio player is started or stopped it then sets the vars appropriately
	my $button  = shift;
	my $station = $_[0][0];
	my $action  = $_[0][1];

	#print "DEBUG:: $station station $action action \n";

	if ( $action eq "start" ) {
		streamStation $station;
		#if it returns assumed it worked may have to check if it failed.
		#disconnect the handler
		$radio_button->signal_handler_disconnect($rb_cb);
		#Change the label
		$radio_button->set_label("Stop Radio: $rb_label");
		$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play, "stop"] );
		#disable the list control 
		$stn_slist->sensitive($false);
		$sr_button->sensitive($false);
	} else {
		stopStation $station;
		#if it returns assumed it worked may have to check if it failed.
		#disconnect the handler
		$radio_button->signal_handler_disconnect($rb_cb);
		#Change the label
		$radio_button->set_label("Play Radio: $rb_label");
		$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play, "start"] );
		$stn_slist->sensitive($true);
		$sr_button->sensitive($true);
	
	}
}

sub start_slideshow {
	if ( $pqiv_proc != 0 ) {
		finish $pqiv_proc;
	}
	#set the backlight to max::
	system('/bin/echo 0 > /sys/class/backlight/openframe-bl/bl_power');
	my @pqivcmd = ( '/usr/bin/pqiv' , '-fsnnid' , '10' , "$Pic_Dir" ); 
	$pqiv_proc = start \@pqivcmd;
	system ('/usr/bin/killall xscreensaver');
	system ('/usr/bin/xset -dpms');
}

sub keyboard_control {
	my $junk = shift;
	my @kbd_command = ( '/usr/bin/matchbox-keyboard' );
	#my @kbd_command = ( '/usr/bin/matchbox-keyboard' , '-xid' );
	if ( $kb_proc == 0 ) {
		my $in;
		my $xid;
		$kb_proc = start \@kbd_command , \$in, \$xid;
		sleep 2;
		#Change the label
		#my $screen = Gnome2::Wnck::Screen -> get_default();
		#$screen -> force_update();
		#my @windows = $screen -> get_windows();
		#my $id;
		#foreach my $window (@windows) {
		#	my $name = $window -> get_name();
		#	print "$name\n";
		#	$id = $window -> get_xid();
		#	print "$id\n";
		#}
		#$kb_button->set_label("Close Keyboard");
		$junk->set_label("Close Keyboard");
		$base_win->set_focus($entry);
	} else {
		$kb_proc->kill_kill;
		kill_kill $kb_proc;
		finish $kb_proc;
		$kb_proc = 0;
		#$kb_button->set_label("Open Keyboard");
		$junk->set_label("Open Keyboard");
	}
}

sub gui_search {
	my $btn  = shift;
	my $srch = $_[0][0];
	my @chnl = ($_[0][1]);
	@gui_res = ();
	@gui_res = searchShow ($srch->get_text , $SelSin , @chnl);
	#return @show_res;
	#print Dumper ( @gui_res );
	@{$res_slist->{data}} = ();
	my $res_c = 1;
	foreach my $res ( @gui_res ) {
		#print "DEBUG:: $stn $Channel{$stn}[2] \n";
		push  (  @{$res_slist->{data}} , ( [$res_c , @$res[1]]));
		++$res_c
		#print Dumper (@{$res_slist->{data}});
	}

}

sub gui_play {
	my $btn = shift;
	my @play   = $_[0][0];
	my $action = $_[0][1];

	print Dumper (@play);
	print "action is $action \n";
	if  ( $action eq "start" ) {
		downloadPID (@play);
		$sr_button->set_label("Stop");
		#Disconnect the buttons callback
		$sr_button->signal_handler_disconnect($sr_cb);
		#reconnect callback handler here, because the value seems to be static
		$sr_cb = $sr_button->signal_connect('clicked' => \&gui_play , [ @play , "stop" ] );
		$stn_slist->sensitive($false);
		$radio_button->sensitive($false);
	} else {
		stopStation "1";
		$sr_button->set_label("Play");
		#Disconnect the buttons callback
		$sr_button->signal_handler_disconnect($sr_cb);
		#reconnect callback handler here, because the value seems to be static
		$sr_cb = $sr_button->signal_connect('clicked' => \&gui_play , [ @play , "start" ] );
		$stn_slist->sensitive($true);
		$radio_button->sensitive($true);
	}
		


}
	

sub startGui {
	#Need to init, as the use if doesn't support init
	Gtk2->init;
	# If loading gui for now assume playing not saving
	$play = 1;
	# Create the window
	$base_win = new Gtk2::Window( "toplevel" );
	$base_win->set_title( "RadioControl" );
	$base_win->signal_connect( "destroy", sub { 
		stopStation;
		if ( $kb_proc != 0 ) {
			$kb_proc->kill_kill;
			kill_kill $kb_proc;
			finish $kb_proc;
		}
		Gtk2->main_quit; });
	$base_win->set_border_width( 5 );

	# Create the main vertical box.
	my $base_vbox = new Gtk2::VBox( $false, $false );
	$base_win->add( $base_vbox );

	# Create a horizontal frame
	my $base_frame = new Gtk2::Frame( "JoggControl" );
	$base_vbox->pack_start( $base_frame, $true, $true, 5 );

	my $top_hbox = new Gtk2::HBox( $false, $false );
	$base_frame->add( $top_hbox );

	my $scrolledwindow=new Gtk2::ScrolledWindow;
	$base_vbox->pack_start( $scrolledwindow, $true, $true, 5 );

	my $sub_hbox = new Gtk2::HBox( $false, $false );
	$base_vbox->pack_start( $sub_hbox, $true, $true, 2 );

	my $hbbox1 = new Gtk2::HButtonBox();
	$hbbox1->set_border_width( 5 );
	$hbbox1->set_layout( "edge" );
	$hbbox1->set_spacing( 5 );

	my $hbbox2 = new Gtk2::HButtonBox();
	$hbbox2->set_border_width( 5 );
	$hbbox2->set_layout( "edge" );
	$hbbox2->set_spacing( 5 );

	my $ss_button = new Gtk2::Button( "SlideShow" );
	$ss_button->signal_connect('clicked' => \&start_slideshow );
	$hbbox1->add( $ss_button );

	my $ssdir_button = Gtk2::FileChooserButton->new('Set SlideShow Folder' , 'select-folder' );
	$ssdir_button->set_current_folder( "$Pic_Dir" );
	$hbbox1->add( $ssdir_button );

	$ssdir_button->signal_connect('current-folder-changed' => sub { 
		$Pic_Dir = $ssdir_button->get_filename;
		#print "DEBUG:: pc_dir $Pic_Dir\n";
		#print Dumper ( $ssdir_button->list_shortcut_folders );
	 });


	my $volup_button = new Gtk2::Button( "Vol Up" );
	$volup_button->signal_connect('clicked' => \&volume , "up" );
	$hbbox2->add( $volup_button );

	my $voldn_button = new Gtk2::Button( "Vol Dn" );
	$voldn_button->signal_connect('clicked' => \&volume , "down" );
	$hbbox2->add( $voldn_button );

	$vol_label = new Gtk2::Label ( "Vol: ?? / 31" );
	$hbbox2->add( $vol_label );

	$mute_button = new Gtk2::Button( "Mute" );
	$mute_button->signal_connect('clicked' => \&volume , "mute" );
	$hbbox2->add( $mute_button );
	
	#Initialise the volume levels
	getvol;

	my $exit_button = new Gtk2::Button( "Exit" );
	$exit_button->signal_connect('clicked' => sub { $base_win->destroy });
	$hbbox2->add( $exit_button );

	$top_hbox->pack_start( $hbbox1, $true, $true, 2 );
	$top_hbox->pack_start( $hbbox2, $true, $true, 2 );

	my $left_vframe = new Gtk2::Frame( "Station Select" );
	my $mid_vframe = new Gtk2::Frame( "AoD Control" );
	my $right_vframe = new Gtk2::Frame( "Status" );

	$sub_hbox->pack_start($left_vframe, $true, $true, 10);
	$sub_hbox->pack_start($mid_vframe, $true, $true, 10);
	$sub_hbox->pack_start($right_vframe, $true, $true, 10);

	$mid_vbbox = new Gtk2::VButtonBox();
	$mid_vbbox->set_border_width( 5 );
	$mid_vframe->add( $mid_vbbox );
	$mid_vbbox->set_layout( "start" );
	$mid_vbbox->set_spacing( 5 );

	#my $temp_button = new Gtk2::Button( "Stop Radio: $Channel{$stn_play}[2]" );
	#$temp_button->signal_connect('clicked' => \&stopStation, $stn_play );
	#$mid_vbbox->add( $temp_button );
	$radio_button = new Gtk2::Button( "Play Radio: $Channel{$stn_play}[2]" );
	$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play , "start"] );
	
	my $left_vbox = new Gtk2::VBox( $false, 0 );
	$left_vframe->add ($left_vbox);
	$stn_slist = Gtk2::SimpleList->new  (
		'ID'	  => 'int',
		'Name'	  => 'text',
        );
	foreach my $stn ( sort {$a <=> $b} ( keys %Channel )) {
		#print "DEBUG:: $stn $Channel{$stn}[2] \n";
		push  (@{$stn_slist->{data}} , ( [$stn, $Channel{$stn}[2]] ));
	}
        $left_vbox->pack_start($stn_slist, $true, $true, 1 );
	
	$entry = Gtk2::Entry->new;
	$sr_button= Gtk2::Button->new( "Search" );
	$sr_cb = $sr_button->signal_connect('clicked' => \&gui_search , [ $entry , $stn_play ] );

        $stn_slist->get_selection->signal_connect ( changed => sub {
                my ($selection) = @_;
                my $stn_slist = $selection->get_tree_view;
                my ($sel) = $stn_slist->get_selected_indices;
                $stn_play = $stn_slist->{data}[$sel][0];
		$rb_label = $stn_slist->{data}[$sel][1];
		$radio_button->set_label("Play Radio: $rb_label");
		$sr_button->set_label("Search");
		#Disconnect the buttons callback
		$radio_button->signal_handler_disconnect($rb_cb);
		$sr_button->signal_handler_disconnect($sr_cb);
		#reconnect callback handler here, because the value seems to be static
		$rb_cb = $radio_button->signal_connect('clicked' => \&controlStation, [$stn_play ,"start"] );
		$sr_cb = $sr_button->signal_connect('clicked' => \&gui_search , [ $entry , $stn_play ] );
        });

	$res_slist = Gtk2::SimpleList->new  (
		'ID'	  => 'int',
		'Title'	  => 'text',
        );
	$scrolledwindow->add_with_viewport($res_slist);
        $res_slist->get_selection->signal_connect ( changed => sub {
                my ($selection) = @_;
                my $res_slist = $selection->get_tree_view;
                my ($sel) = $res_slist->get_selected_indices;
                my $res_play = $res_slist->{data}[$sel][0];
		#$rb_label = $stn_slist->{data}[$sel][1];
		$sr_button->set_label("Play");
		#Disconnect the buttons callback
		$sr_button->signal_handler_disconnect($sr_cb);
		#reconnect callback handler here, because the value seems to be static
		$sr_cb = $sr_button->signal_connect('clicked' => \&gui_play, [$gui_res[--$res_play], "start"] );
        });

	my $choose_button = Gtk2::FileChooserButton->new('Select Mp3' , 'open' );
	$choose_button->set_width_chars(10);

	my $kb_button= Gtk2::Button->new( "Open Keyboard" );
	$kb_button->signal_connect('clicked' => \&keyboard_control);

	my $pp_button= Gtk2::Button->new( "Pause/Cont." );
	$pp_button->signal_connect('clicked' => sub {
		if ( $mply_proc != 0 ) {
			system '/bin/echo pause > /tmp/mplayer.fifo';
		}
	});

	my $cc_button = Gtk2::Button->new( "Clear AoD Cache" );
	$cc_button->signal_connect('clicked' => sub {
		foreach my $station ( %Channel ) {
			undef $Channel{$station}[3];
		}
	});

	$mid_vbbox->add($entry);
	$mid_vbbox->add($kb_button);
	$mid_vbbox->add($sr_button);
        $mid_vbbox->add($radio_button);
        $mid_vbbox->add($pp_button);
        $mid_vbbox->add($cc_button);
        #$mid_vbbox->add($choose_button);


	my $right_vbbox = new Gtk2::VButtonBox();
	$right_vbbox->set_border_width( 5 );
	$right_vframe->add( $right_vbbox );
	$right_vbbox->set_layout( "start" );
	$right_vbbox->set_spacing( 10 );
	my $wlan_label = new Gtk2::Label ( "wlan0 IP Address:" );
	$right_vbbox->add( $wlan_label );
	my $wlan_ip = ip_addr 'wlan0';
	$wlan_addr = new Gtk2::Label ( $wlan_ip );
	$right_vbbox->add( $wlan_addr );
	my $eth_label = new Gtk2::Label ( "eth0 IP Address:" );
	$right_vbbox->add( $eth_label );
	my $eth_ip = ip_addr 'eth0';
	$eth_addr = new Gtk2::Label ( $eth_ip );
	$right_vbbox->add( $eth_addr );

	my $refresh_button = new Gtk2::Button( "_Refresh" );
	$refresh_button->signal_connect('clicked' => \&refresh_status );
	$right_vbbox->add( $refresh_button );

	$base_win->show_all;
	Gtk2->main;

}


#Main Code starts here
#Always convert the channel to an array (needs error checking)#
#For a live stream only use the first one
@SelChn = split(/,/,join(',',@SelChn));
#If its live we can bypass the search part and jump straight to the streaming


if ( $Gui  == 1 ) {
	#hack try to stop mplayer
	#system '/bin/echo stop > /tmp/mplayer.fifo';
	system '/usr/bin/killall mplayer';
	#print ("load gui");
	startGui
} elsif ( $live == 1 ) {
	#print "\nDEBUG:: in main streamStation $SelChn[0] \n";
	streamStation ( $SelChn[0] );
} elsif ( length($DrtPID) > 0 ) {
	#Attempt to dump the pid, use the title if it is a title
	if ( isitaPID($DrtPID) == 1 ) {
		my @Results = ();
		my @TmpArray =();
		print "it is a PID $DrtPID and the title is $Title";
		@TmpArray = ($DrtPID,$Title);
		@Results = ([@TmpArray]);
		downloadPID (@Results);
	} else {
		print "it is not a pid";
	}
} else {
	my @Results = ();
	foreach my $look (@SelSer) {
		push ( @Results  , (searchFeeds ( $look , $SelSin , @SelChn )));
	}
		if ( $get == 1 ) {
			#print "calling downloadPID \n";
			downloadPID (@Results);
		} else {
			if (@Results) {
				print Dumper (@Results);
				print "Do you want to download these shows (y/n)\n";
				chomp ( my $res = <STDIN>);
				if ( $res =~ /^y/i ) {
					downloadPID (@Results);
				}
			}
		}
}
